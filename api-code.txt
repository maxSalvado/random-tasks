# 0) Vars
export REGION_PUB=us-east-1
export PUBLIC_REPO_NAME=monabot-api

# 1) Make an isolated Docker config (no credential helpers)
mkdir -p ~/.docker-ecrpub
printf '{ "auths": {} }\n' > ~/.docker-ecrpub/config.json

# 2) Fresh login to ECR Public (store creds in the isolated config)
DOCKER_CONFIG=~/.docker-ecrpub \
aws ecr-public get-login-password --region "$REGION_PUB" \
| DOCKER_CONFIG=~/.docker-ecrpub docker login --username AWS --password-stdin public.ecr.aws




# 3) Get your canonical public repo URI (includes your alias/namespace)
PUBLIC_REPO_URI=$(
  aws ecr-public describe-repositories --region "$REGION_PUB" \
  --repository-names "$PUBLIC_REPO_NAME" \
  --query 'repositories[0].repositoryUri' --output text
)
echo "Public URI: $PUBLIC_REPO_URI"   # e.g. public.ecr.aws/<your-alias>/monabot-api

# 4) Build / tag / push
TAG="v$(date +%Y%m%d-%H%M)"
docker build -t "$PUBLIC_REPO_NAME:$TAG" .
docker tag   "$PUBLIC_REPO_NAME:$TAG" "$PUBLIC_REPO_URI:$TAG"
DOCKER_CONFIG=~/.docker-ecrpub docker push "$PUBLIC_REPO_URI:$TAG"

# (Keep DOCKER_CONFIG=~/.docker-ecrpub for any future docker login/push to ECR Public)



--- AFTER PUSH ----


#!/usr/bin/env bash
set -euo pipefail

# ---- EDIT THESE (your ECS info) ----
export CLUSTER="<your-ecs-cluster>"
export SERVICE="<your-ecs-service>"
export CONTAINER_NAME="<your-container-name>"
# ------------------------------------

# Your public ECR repo
export REGION_PUB="us-east-1"
export PUBLIC_REPO_NAME="monabot-api"

# 1) Resolve the canonical public repo URI and the *latest* tag you pushed
PUBLIC_REPO_URI=$(
  aws ecr-public describe-repositories \
    --region "$REGION_PUB" \
    --repository-names "$PUBLIC_REPO_NAME" \
    --query 'repositories[0].repositoryUri' \
    --output text
)

# If you know the tag you used, set TAG manually here:
# TAG="v20250821-1035-abc123"
# Otherwise, auto-detect the most recently pushed tag:
TAG=$(
  aws ecr-public describe-images \
    --region "$REGION_PUB" \
    --repository-name "$PUBLIC_REPO_NAME" \
    --query 'sort_by(imageDetails, &imagePushedAt)[-1].imageTags[0]' \
    --output text
)

echo "Using image: $PUBLIC_REPO_URI:$TAG"

# 2) Capture current task def (for rollback) and fetch its JSON
PREV_TD_ARN=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" \
  --query "services[0].taskDefinition" --output text)
echo "Current task def: $PREV_TD_ARN"

aws ecs describe-task-definition --task-definition "$PREV_TD_ARN" \
  --query "taskDefinition" > td.json

# 3) Strip read-only fields and swap the container image to ECR Public URI
jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' td.json \
| jq --arg name "$CONTAINER_NAME" --arg img "$PUBLIC_REPO_URI:$TAG" \
     '.containerDefinitions = (.containerDefinitions
        | map(if .name == $name then .image = $img | . else . end))' \
> td.updated.json

# 4) Register new task definition revision
NEW_TD_ARN=$(aws ecs register-task-definition \
  --cli-input-json file://td.updated.json \
  --query "taskDefinition.taskDefinitionArn" --output text)
echo "New task def: $NEW_TD_ARN"

# 5) Update service and wait for it to stabilize
aws ecs update-service --cluster "$CLUSTER" --service "$SERVICE" --task-definition "$NEW_TD_ARN" >/dev/null
aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE"

# 6) Show deployments
aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" \
  --query "services[0].deployments"

